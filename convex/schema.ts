import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";
import { authTables } from "@convex-dev/auth/server";

export default defineSchema({
  ...authTables,

  // Custom user profiles (separate from authTables "users")
  profiles: defineTable({
    name: v.string(),
    email: v.string(),
    role: v.union(v.literal("member"), v.literal("admin"), v.literal("moderator")),
    phone: v.optional(v.string()),
    profileImageStorageId: v.optional(v.id("_storage")),
    authUserId: v.string(),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_authUserId", ["authUserId"])
    .index("by_email", ["email"]),

  // Sou-Sou batches
  batches: defineTable({
    number: v.number(),
    status: v.union(v.literal("open"), v.literal("closed")),
    maxMembers: v.number(),
    frequency: v.optional(v.union(v.literal("weekly"), v.literal("monthly"))),
    duration: v.optional(v.number()),
    amount: v.optional(v.number()),
    payoutOrderLocked: v.optional(v.boolean()),
    cycleStartDate: v.optional(v.number()),
    fairnessSeedCommitHash: v.optional(v.string()),
    fairnessSeedSecret: v.optional(v.string()), // store safely, only revealed if requested
    fairnessSeedRevealed: v.optional(v.boolean()),
    createdAt: v.number(),
    closedAt: v.optional(v.number()),
  })
    .index("by_number", ["number"])
    .index("by_status", ["status"]),

  // Batch memberships
  batchMembers: defineTable({
    batchId: v.id("batches"),
    userId: v.id("profiles"),
    memberNumber: v.number(),
    displayName: v.string(),
    joinedAt: v.number(),
    payoutMonth: v.optional(v.number()),
    payoutStatus: v.optional(v.union(v.literal("pending"), v.literal("paid"))),
    paidAt: v.optional(v.number()),
  })
    .index("by_batchId", ["batchId"])
    .index("by_userId", ["userId"])
    .index("by_batchId_memberNumber", ["batchId", "memberNumber"])
    .index("by_batchId_userId", ["batchId", "userId"]),

  // Leave requests for open batches
  leaveRequests: defineTable({
    batchId: v.id("batches"),
    userId: v.id("profiles"),
    status: v.union(v.literal("pending"), v.literal("approved"), v.literal("denied")),
    reason: v.optional(v.string()),
    requestedAt: v.number(),
    resolvedAt: v.optional(v.number()),
  })
    .index("by_batchId", ["batchId"])
    .index("by_userId", ["userId"])
    .index("by_batchId_userId", ["batchId", "userId"])
    .index("by_status", ["status"]),

  // Encrypted leave codes generated by admins
  leaveCodes: defineTable({
    batchId: v.id("batches"),
    code: v.string(),
    codeHash: v.string(),
    generatedBy: v.id("profiles"),
    used: v.boolean(),
    usedBy: v.optional(v.id("profiles")),
    usedAt: v.optional(v.number()),
    createdAt: v.number(),
  })
    .index("by_batchId", ["batchId"])
    .index("by_codeHash", ["codeHash"]),

  // User banking information
  bankingInfo: defineTable({
    userId: v.id("profiles"),
    firstName: v.string(),
    lastName: v.string(),
    bankName: v.string(),
    accountType: v.union(v.literal("chequing"), v.literal("savings")),
    accountNumber: v.string(),
    currency: v.union(v.literal("TTD"), v.literal("USD")),
    updatedAt: v.number(),
  })
    .index("by_userId", ["userId"]),

  // Admin default bank account (for receiving payments)
  adminBankAccount: defineTable({
    adminId: v.id("profiles"),
    firstName: v.string(),
    lastName: v.string(),
    bankName: v.string(),
    accountType: v.union(v.literal("chequing"), v.literal("savings")),
    accountNumber: v.string(),
    currency: v.union(v.literal("TTD"), v.literal("USD")),
    conversionRate: v.number(), // USD to TTD rate (e.g. 6.78)
    isDefault: v.boolean(),
    updatedAt: v.number(),
  })
    .index("by_adminId", ["adminId"])
    .index("by_isDefault", ["isDefault"]),

  // Payment verification - admin marks users as paid before they can join a batch
  paymentVerifications: defineTable({
    userId: v.id("profiles"),
    batchId: v.id("batches"),
    verified: v.boolean(),
    verifiedBy: v.id("profiles"),
    verifiedAt: v.number(),
  })
    .index("by_userId", ["userId"])
    .index("by_batchId", ["batchId"])
    .index("by_batchId_userId", ["batchId", "userId"]),

  // Public Contact Messages
  contactMessages: defineTable({
    name: v.string(),
    email: v.string(),
    subject: v.string(),
    message: v.string(),
    createdAt: v.number(),
    status: v.union(v.literal("new"), v.literal("read")),
  }).index("by_status", ["status"]),

  // Invite Codes for new member registration
  inviteCodes: defineTable({
    code: v.string(), // Plaintext code (stored in db or hash, but assignment says "encrypted") - Let's store hash and encrypted code or just unique code. "Each code will be encrypted and unique to that member it was assigned to".
    // Wait, let's keep it simple first. "encrypted and unique to that member it was assigned to" -> usually a hashed code, salt if necessary. But to map to a member, we can just store the 'assignedEmail' or just the code string because the admin generates it.
    codeHash: v.string(),
    assignedToEmail: v.optional(v.string()), // Optionally lock to a specific email
    createdBy: v.id("profiles"), // The admin who created it
    used: v.boolean(),
    usedBy: v.optional(v.id("profiles")),
    usedAt: v.optional(v.number()),
    createdAt: v.number(),
  })
    .index("by_codeHash", ["codeHash"])
    .index("by_assignedToEmail", ["assignedToEmail"]),
});
